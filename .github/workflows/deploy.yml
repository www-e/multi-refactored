name: Agentic Auto-Deploy

on:
  push:
    branches: [ "main" ]

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  deploy_and_verify:
    name: Build, Deploy & Health Check
    runs-on: ubuntu-latest
    
    steps:
      - name: Executing remote SSH commands
        uses: appleboy/ssh-action@v1.0.0
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USER }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          script_stop: true
          script: |
            # --- CONFIGURATION ---
            PROJECT_DIR="/var/www/voice_agent"
            
            # Container Names (matching docker-compose.yml container_name)
            DB_CONTAINER="agentic_portal_db"
            BACKEND_CONTAINER="agentic_portal_backend"
            FRONTEND_CONTAINER="agentic_portal_frontend"

            echo "üîì Force-cleaning any stale lock files..."
            rm -f "/tmp/agentic_portal_deploy.lock" "/tmp/agentic_portal_deploy.info"
            
            echo "üßπ Pre-deployment cleanup..."
            docker system prune -f 2>/dev/null || true
            
            # Check disk space
            AVAILABLE_SPACE=$(df / | tail -1 | awk '{print $4}')
            if [ "$AVAILABLE_SPACE" -lt 1048576 ]; then
                echo "‚ö†Ô∏è  WARNING: Low disk space! Pruning images..."
                docker image prune -a -f
            fi
            
            # 1. Navigate to Project
            cd $PROJECT_DIR
            echo "üìÅ Changed directory to $PROJECT_DIR"
            
            PREVIOUS_COMMIT=$(git rev-parse HEAD)
            
            # 2. Sync Code
            echo "üì• Pulling latest code..."
            git fetch --all
            git reset --hard origin/main
            CURRENT_COMMIT=$(git rev-parse HEAD)
            echo "üìä Deploying: $PREVIOUS_COMMIT ‚Üí $CURRENT_COMMIT"
            
            # 3. Backup Database
            echo "üíæ Creating database backup..."
            BACKUP_FILE="backups/agentic_portal_$(date +%Y%m%d_%H%M%S).sql"
            mkdir -p backups
            docker exec $DB_CONTAINER pg_dump -U navaia navaia > "$BACKUP_FILE" 2>/dev/null || echo "‚ö†Ô∏è  Backup skipped (DB may not exist yet)"
            ls -t backups/*.sql 2>/dev/null | tail -n +4 | xargs -r rm
            
            # 4. Rebuild and Restart
            echo "üèóÔ∏è Building and Starting Docker Containers..."
            if ! docker-compose up -d --build --force-recreate --remove-orphans; then
                echo "‚ùå Docker build failed! Rolling back..."
                git reset --hard $PREVIOUS_COMMIT
                docker-compose up -d
                exit 1
            fi
            
            # 5. Wait for PostgreSQL
            echo "‚è≥ Waiting for PostgreSQL..."
            for i in {1..30}; do
                if docker exec $DB_CONTAINER pg_isready -U navaia > /dev/null 2>&1; then
                    echo "‚úÖ PostgreSQL is ready!"
                    break
                fi
                [ $i -eq 30 ] && { echo "‚ùå PostgreSQL failed to start!"; exit 1; }
                sleep 1
            done
            
            # 6. Database Migrations
            echo "üîÑ Checking Database State & Running Migrations..."

            # Wait a bit for the DB to be completely ready
            sleep 5

            # Retry logic for database connectivity
            CONNECTED=false
            for i in {1..10}; do
                if docker exec $BACKEND_CONTAINER python -c "
import os
from sqlalchemy import create_engine
try:
    engine = create_engine(os.getenv('DB_URL', 'postgresql://navaia:navaia@agentic_db:5432/navaia'))
    with engine.connect() as conn:
        conn.execute('SELECT 1')
    print('CONNECTED')
except:
    print('ERROR')
" | grep -q "CONNECTED"; then
                    CONNECTED=true
                    break
                fi
                echo "‚è≥ Waiting for DB connectivity... ($i/10)"
                sleep 3
            done

            if [ "$CONNECTED" = false ]; then
                echo "‚ùå Unable to connect to database!"
                docker logs $BACKEND_CONTAINER --tail 30
                exit 1
            fi

            # First, check current alembic revision to see what's applied
            CURRENT_REVISION=$(docker exec $BACKEND_CONTAINER alembic current 2>&1 || echo "NO_REVISION")

            if [[ "$CURRENT_REVISION" == *"No revision"* ]] || [[ "$CURRENT_REVISION" == "NO_REVISION" ]]; then
                echo "üìö No alembic revision found - checking if tables exist..."

                # Check if tables exist by trying to get table count (using a simple SQL query through alembic db connection)
                TABLES_EXIST=$(docker exec $BACKEND_CONTAINER python -c "
from sqlalchemy import create_engine, text
import os
try:
    engine = create_engine(os.getenv('DB_URL', 'postgresql://navaia:navaia@agentic_db:5432/navaia'))
    with engine.connect() as conn:
        result = conn.execute(text(\"SELECT COUNT(*) FROM information_schema.tables WHERE table_schema = 'public' AND table_name != 'alembic_version';\"))
        count = result.scalar()
        print('EXISTS' if count > 0 else 'NONE')
except Exception as e:
    print('ERROR')
" 2>/dev/null || echo "ERROR")

                if [ "$TABLES_EXIST" = "EXISTS" ]; then
                    echo "üìÅ Tables exist but no alembic tracking - marking latest revision as current..."
                    # Check if alembic_version table exists, if not create it first
                    ALEMBIC_VERSION_TABLE=$(docker exec $BACKEND_CONTAINER python -c "
from sqlalchemy import create_engine, text
import os
try:
    engine = create_engine(os.getenv('DB_URL', 'postgresql://navaia:navaia@agentic_db:5432/navaia'))
    with engine.connect() as conn:
        result = conn.execute(text(\"SELECT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'alembic_version');\"))
        exists = result.fetchone()[0]
        print('EXISTS' if exists else 'NOT_EXISTS')
except Exception:
    print('ERROR')
" 2>/dev/null || echo "ERROR")

                    if [ "$ALEMBIC_VERSION_TABLE" != "EXISTS" ]; then
                        echo "üîß Creating alembic version table..."
                        docker exec $BACKEND_CONTAINER alembic stamp base
                    fi

                    # Stamp the head revision as already applied to avoid re-creating existing tables
                    docker exec $BACKEND_CONTAINER alembic stamp head
                    echo "üîÑ Now running any pending upgrades..."
                    docker exec $BACKEND_CONTAINER alembic upgrade head
                elif [ "$TABLES_EXIST" = "ERROR" ]; then
                    # Database connection issue - try fresh migration
                    echo "‚ö†Ô∏è Database check failed, attempting fresh migration..."
                    docker exec $BACKEND_CONTAINER alembic upgrade head
                else
                    # Fresh database - run normal migration
                    echo "üå± Fresh database, running initial migration..."
                    docker exec $BACKEND_CONTAINER alembic upgrade head
                fi
            else
                # Alembic tracking exists - run normal upgrade to apply new migrations
                echo "üìã Alembic tracking found (revision: $CURRENT_REVISION), running upgrade..."
                docker exec $BACKEND_CONTAINER alembic upgrade head
            fi

            # Check migration result
            MIGRATION_EXIT_CODE=$?
            if [ $MIGRATION_EXIT_CODE -ne 0 ]; then
                echo "‚ùå Migration Failed!"
                echo "üîç Checking alembic history:"
                docker exec $BACKEND_CONTAINER alembic history || true
                echo "üîç Current revision state:"
                docker exec $BACKEND_CONTAINER alembic current || true
                echo "üîç Available revisions:"
                docker exec $BACKEND_CONTAINER alembic branches || true
                docker logs $BACKEND_CONTAINER --tail 80
                exit 1
            fi

            echo "‚úÖ Migrations completed successfully!"
            echo "üìã Final revision state:"
            docker exec $BACKEND_CONTAINER alembic current || echo "Could not retrieve current revision"
            
            # 7. Post-Cleanup
            docker image prune -f
            
            # 8. Health Checks
            echo "üí§ Warming up services (waiting 10s)..."
            sleep 10
            
            check_health() {
                local url=$1
                local name=$2
                local max_retries=12
                local wait_time=5
                
                echo "üè• Checking $name at $url..."
                
                for i in $(seq 1 $max_retries); do
                    # Capture HTTP Status Code (000 = Connection Failed)
                    STATUS=$(curl -s -o /dev/null -w "%{http_code}" "$url" || echo "000")
                    
                    # Accept 2xx and 3xx as healthy (3xx = redirects are OK)
                    if [ "$STATUS" -ge 200 ] && [ "$STATUS" -lt 400 ]; then
                        echo "‚úÖ $name is HEALTHY! (Status: $STATUS)"
                        return 0
                    fi
                    
                    echo "‚è≥ $name not ready (Status: $STATUS)... waiting ${wait_time}s ($i/$max_retries)"
                    sleep $wait_time
                done
                
                echo "‚ùå $name failed to start after $((max_retries * wait_time))s."
                return 1
            }
            
            # Check Backend
            if ! check_health "http://127.0.0.1:8000/healthz" "Backend"; then
                echo "üîç DUMPING BACKEND LOGS:"
                docker logs $BACKEND_CONTAINER --tail 50
                exit 1
            fi
            
            # Check Frontend
            if ! check_health "http://127.0.0.1:3001" "Frontend"; then
                echo "üîç DUMPING FRONTEND LOGS:"
                docker logs $FRONTEND_CONTAINER --tail 50
                exit 1
            fi
            
            echo "üöÄ Deployment Complete!"
            echo "üì¶ Backup: $BACKUP_FILE"
